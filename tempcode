import numpy as np
from scipy.stats import wasserstein_distance  # Earth Moverâ€™s Distance
from sqlalchemy import create_engine, text
import matplotlib.pyplot as plt

class SEEDB:
    def __init__(self, engine, dimension_attributes, measure_attributes, aggregate_functions):
        self.engine = engine
        self.A = dimension_attributes
        self.M = measure_attributes
        self.F = aggregate_functions
        self.DR = 'census'  # default reference dataset

    def execute_query(self, query):
        with self.engine.connect() as conn:
            res = conn.execute(text(query))
            return dict(res.fetchall())

    def normalize(self, data):
        return {k: v / sum(data.values()) for k, v in data.items()}

    def utility(self, Vi, DQ):
        QT = f"SELECT {Vi[0]}, {Vi[2]}({Vi[1]}) FROM {DQ} GROUP BY {Vi[0]}"
        QR = f"SELECT {Vi[0]}, {Vi[2]}({Vi[1]}) FROM {self.DR} GROUP BY {Vi[0]}"

        target_view = self.execute_query(QT)
        reference_view = self.execute_query(QR)

        target_distribution = self.normalize(target_view)
        reference_distribution = self.normalize(reference_view)

        return wasserstein_distance(list(target_distribution.values()), list(reference_distribution.values()))

    def recommend(self, Q, k):
        views = [(a, m, f) for a in self.A for m in self.M for f in self.F]
        utilities = [(Vi, self.utility(Vi, Q)) for Vi in views]
        utilities.sort(key=lambda x: x[1], reverse=True)
        return utilities[:k]

    def visualize(self, target, ref, params):
        bars = len(target)
        grp_by_attr, msr_attr, agg_func = params

        figure, _ = plt.subplots()
        idx = np.arange(bars)
        width = 0.4

        target_vals = list(target.values())
        ref_vals = list(ref.values())

        rects1 = plt.bar(idx, target_vals, width, color='m', label='married')
        rects2 = plt.bar(idx + width, ref_vals, width, color='b', label='unmarried')

        plt.xlabel('{}'.format(grp_by_attr))
        plt.ylabel('{}({})'.format(agg_func, msr_attr))
        plt.xticks(idx + width/2, target.keys(), rotation=45)
        plt.legend()

        plt.tight_layout()
        plt.show()

F = {"COUNT", "SUM", "AVG", "MAX", "MIN"}
A = {"workclass", "education", "marital_status", "occupation", "relationship", "race", "sex", "native_country", "income"}
M = {"fnlwgt", "age", "capital_gain", "capital_loss", "hours_per_week"}

seedb = SEEDB(engine, A, M, F)
recommendations = seedb.recommend('married', 5)

for Vi, utility in recommendations:
    target = seedb.execute_query(f"SELECT {Vi[0]}, {Vi[2]}({Vi[1]}) FROM married GROUP BY {Vi[0]}")
    ref = seedb.execute_query(f"SELECT {Vi[0]}, {Vi[2]}({Vi[1]}) FROM unmarried GROUP BY {Vi[0]}")
    seedb.visualize(target, ref, Vi)
